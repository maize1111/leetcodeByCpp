#include <bits/stdc++.h>
using namespace std;
//超时
//需要优化

int closestToTarget(vector<int> &arr, int target)
{
    //记录大于target的最小值
    int minnum = 10000001;
    vector<int> newarr;
    int res = INT_MAX;
    
    //若tmp和target相等直接返回0即可
    //若tmp小于target，则从其开始向后所有的结果只会越来越远离target，则不用进入内循环直接更新res即可
    //若tmp比minnum大也不必进入内循环
    //另外去重也可以优化
    unordered_set<int> s;
    for(auto a:arr){
        if(s.find(a)==s.end()){
            s.insert(a);
            newarr.push_back(a);
        }
        
    }
    int len = newarr.size();
    for (int i = 0; i < len; i++)
    {
        int tmp = newarr[i];
        if (tmp == target)
        {
            return 0;
        }
        else if (tmp < target)
        {
            res = min(res, abs(target - tmp));
        }
        else
        {
            if (tmp < minnum)
            {
                for (int j = i; j < len; j++)
                {
                    tmp &= newarr[j];
                    res = min(res, abs(target - tmp));
                    if (tmp < target)
                        break;
                }
            }
        }
    }

    return res;
}
int main()
{
    vector<int> arr = {10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10101,10102,10102,10102,10102,10102,10101,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10101,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10101,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102,10102};
    int target = 22;
    int res = closestToTarget(arr, target);
    cout << res << endl;
    return 0;
}

// 输入：arr = [9,12,3,7,15], target = 5
// 输出：2